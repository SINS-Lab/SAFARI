C********************************************************************
C
      SUBROUTINE DSETUP(N)
C
      real*8 dparam(10),dcirc(4,4),dseg(4,4),xdtect(3)
      common/dparam/dparam,ndtect
      common/dlimit/dcirc,dseg,xdtect
C SET UP DETECTOR TYPE N.
C
      IF(N.EQ.1) THEN
         CALL SPOT
      ELSE IF(N.EQ.2) THEN
         CALL STRIPE
      ELSE IF(N.EQ.3) THEN
         CALL GEODE
      ELSE IF(N.EQ.4) THEN
         CALL THPH
      ELSE
         WRITE(0,*) ' DSETUP: INVALID DETECTOR SPECIFICATION.'
      ENDIF
      RETURN
      END
C
C********************************************************************
C
      SUBROUTINE SPOT
C
C SPOT DETECTOR.
C THE DETECTOR IS A CIRCLE OF ANGULAR WIDTH WIDTH  (see note) CENTERED AT THE
C POINT THETA, PHI.
c  *NOTE* the circle is formed by taking two radii with an opening angle
c of WIDTH, and rotating one about the other, forming a circle on the
c unit sphere.  If the detector axis is at theta0,phi0 and a trajectory
c has a direction theta1,phi0, then it will be in the detector if
c dabs(theta0-theta1)<=WIDTH
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 DCIRC(4,4),DSEG(4,4),XDTECT(3)
      REAL*8 DPARAM(10)
C
      COMMON/DLIMIT/DCIRC,DSEG,XDTECT
      COMMON/DPARAM/DPARAM,NDTECT
      COMMON/UTILTY/DZERO, XNULL(4), PI
C
      THETA=DPARAM(1)
      PHI=DPARAM(2)
      WIDTH=DPARAM(3)
C
C GET AXIS VECTOR.
      CALL UNIT(THETA,PHI,DCIRC(1,1))
C GET ANGLE.
      DCIRC(4,1)=DCOS(WIDTH*PI/180.0D0)
C THE SEGMENT IS THE WHOLE CIRCLE.
      CALL UNIT(THETA-PHI,PHI,DSEG(1,1))
      DSEG(4,1)=-1.0D0
C THE POINT ON THE AXIS IS THE POINT INSIDE.
      CALL EQUATE(XDTECT,DCIRC(1,1))
C THE OTHER THREE SIDES ARE NULL.
      DO 10 I=2,4
         DO 10 J=1,4
            DCIRC(J,I)=0.0D0
            DSEG(J,I)=0.0D0
10    CONTINUE
      RETURN
      END
C
C********************************************************************
C
      SUBROUTINE STRIPE
C
C STRIPE DETECTOR.
C The detector is a stripe.  Two sides are geodesics at theta1 and theta2.
C The other two side are parallel to the vertical great circle at phi = phi.
C The full angular width of the stripe at the is width.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 DCIRC(4,4),DSEG(4,4),XDTECT(3)
      REAL*8 DPARAM(10)
      REAL*8 CORN1(3),CORN2(3),CORN3(3),CORN4(3)
      REAL*8 X1(3),X2(3),VMID1(3),VMID2(3)
C
      COMMON/DLIMIT/DCIRC,DSEG,XDTECT
      COMMON/DPARAM/DPARAM,NDTECT
      COMMON/UTILTY/DZERO, XNULL(4), PI
C
      THETA1=DPARAM(1)
      THETA2=DPARAM(2)
      PHI=DPARAM(3)
      WIDTH=DPARAM(4)
C
C THE POINT INSIDE THE DETECTOR IS AT PHI AND THE AVERAGE THETA.
      CALL UNIT(0.5D0*(THETA1+THETA2),PHI,XDTECT)
C
C SET UP CIRCLES FOR GEODESIC SIDES. (SIDES 1 AND 3)
      CALL UNIT(THETA1+90.0D0,PHI,DCIRC(1,1))
      DCIRC(4,1)=0.0D0
      CALL UNIT(THETA2+90.0D0,PHI,DCIRC(1,3))
      DCIRC(4,3)=0.0D0
C
C SET UP CIRCLES FOR OTHER LINES. (SIDES 2 AND 4)
      CALL UNIT(90.0D0,PHI+90.0D0,DCIRC(1,2))
      CALL MSCALR(DCIRC(1,2),-1.0D0,DCIRC(1,4))
      DCIRC(4,2)=DSIN(0.5D0*WIDTH*PI/180.0D0)
      DCIRC(4,4)=DCIRC(4,2)
C
C CREATE VECTORS TO THE CENTERS OF THE GEODESIC SIDES.
      CALL UNIT(THETA1,PHI,VMID1)
      CALL UNIT(THETA2,PHI,VMID2)
C
C
C FIND THE INTERSECTIONS BETWEEN THE SIDES.
C       FIRST, SIDES ONE AND TWO.
      II=ICSECT(DCIRC(1,1),DCIRC(1,2),X1,X2)
      IF(II.EQ.0) GO TO 666
      CALL CLOSER(X1,X2,VMID1,CORN1)
C
C       ... SIDES TWO AND THREE ...
      II=ICSECT(DCIRC(1,2),DCIRC(1,3),X1,X2)
      IF(II.EQ.0) GO TO 666
      CALL CLOSER(X1,X2,VMID2,CORN2)
C
C       ... SIDES THREE AND FOUR ...
      II=ICSECT(DCIRC(1,3),DCIRC(1,4),X1,X2)
      IF(II.EQ.0) GO TO 666
      CALL CLOSER(X1,X2,VMID2,CORN3)
C
C       ... AND SIDES FOUR AND ONE.
      II=ICSECT(DCIRC(1,4),DCIRC(1,1),X1,X2)
      IF(II.EQ.0) GO TO 666
      CALL CLOSER(X1,X2,VMID1,CORN4)
C
C KNOWING THE CORNERS, WE CAN CREATE THE SEGMENTS.
C THERE CAN BE NO SITUATION IN WHICH THE LONGER SEGMENT JOINING TWO
C POINTS IS DESIRED, UNLESS THE USER IS LOOKING FOR TRAJECTORIES WITH
C THETA > 90. IN THAT CASE, HE CAN WRITE HIS OWN ROUTINES.
      CALL SEGMNT(DCIRC(1,1),CORN4,CORN1,.TRUE.,DSEG(1,1))
      CALL SEGMNT(DCIRC(1,2),CORN1,CORN2,.TRUE.,DSEG(1,2))
      CALL SEGMNT(DCIRC(1,3),CORN2,CORN3,.TRUE.,DSEG(1,3))
      CALL SEGMNT(DCIRC(1,4),CORN3,CORN4,.TRUE.,DSEG(1,4))
C
C IF AN ARC GOES FROM THE EQUATOR TO THE EQUATOR, THEN SEGMNT MAY
C HAVE PICKED THE WRONG HEMISPHERE.
      IF(DABS(THETA1)-90.0D0.LT.DZERO .AND.
     &         DABS(THETA2)-90.0D0.LT.DZERO) THEN
         DSEG(3,2)=DABS(DSEG(3,2))
         DSEG(3,4)=DABS(DSEG(3,4))
      ENDIF
C
      RETURN
C
C ERROR.
666   CONTINUE
      WRITE(0,*) ' STRIPE: ERROR CIRCLES DON''T INTERSECT.'
      RETURN
      END
C
C******************************************************************
C
      SUBROUTINE CLOSER(X1,X2,VMID,CORN)
C
C FIND WHICH OF THE POINTS X1 OR X2 IS CLOSER TO THE POINT VMID
C AND RETURN IT AS CORN.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 X1(3),X2(3),VMID(3),CORN(3)
      IF(DOT(X1,VMID).GE.DOT(X2,VMID)) THEN
         CALL EQUATE(CORN,X1)
      ELSE
         CALL EQUATE(CORN,X2)
      ENDIF
      RETURN
      END
C
C***********************************************************************
C
      SUBROUTINE GEODE
C
C CREATE THE VECTORS REPRESENTING THE SIDES AND CORNERS OF THE
C ANGULAR DETECTOR.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 DCIRC(4,4),DSEG(4,4),XDTECT(3)
      REAL*8 WORK1(3),WORK2(3),WORK0(3)
      REAL*8 DPARAM(10)
      COMMON/DLIMIT/DCIRC,DSEG,XDTECT
      COMMON/DPARAM/DPARAM,NDTECT
C
      THMIN=DPARAM(1)
      THMAX=DPARAM(2)
      PHMIN=DPARAM(3)
      PHMAX=DPARAM(4)
C
C CREATE GEODESIC DETECTOR SIDES AND AVERAGE THE CORNERS.
C
      CALL UNIT(THMAX,PHMIN,WORK1)
      CALL EQUATE(WORK0,WORK1)
      CALL EQUATE(XDTECT,WORK1)
      CALL UNIT(THMAX,PHMAX,WORK2)
      CALL VADD(WORK2,XDTECT,XDTECT)
      CALL GSGMNT(WORK1,WORK2,.TRUE.,DCIRC(1,1),DSEG(1,1))
      CALL UNIT(THMIN,PHMAX,WORK1)
      CALL VADD(WORK1,XDTECT,XDTECT)
      CALL GSGMNT(WORK1,WORK2,.TRUE.,DCIRC(1,2),DSEG(1,2))
      CALL UNIT(THMIN,PHMIN,WORK2)
      CALL VADD(WORK2,XDTECT,XDTECT)
      CALL GSGMNT(WORK1,WORK2,.TRUE.,DCIRC(1,3),DSEG(1,3))
      CALL GSGMNT(WORK0,WORK2,.TRUE.,DCIRC(1,4),DSEG(1,4))
C
      CALL NORM(XDTECT)
C
      RETURN
      END
C
C***********************************************************************
C
      SUBROUTINE THPH
C
C CREATE THE VECTORS REPRESENTING THE SIDES AND CORNERS OF THE
C ANGULAR DETECTOR.
C
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 DCIRC(4,4),DSEG(4,4),XDTECT(3)
      REAL*8 CORNER(3,4)
      REAL*8 DPARAM(10)
      LOGICAL SHORT
      COMMON/DLIMIT/DCIRC,DSEG,XDTECT
      COMMON/DPARAM/DPARAM,NDTECT
      COMMON/UTILTY/DZERO, XNULL(4), PI
C
      THMIN=DPARAM(1)
      THMAX=DPARAM(2)
      PHMIN=DPARAM(3)
      PHMAX=DPARAM(4)
      IF(THMIN.LT.0.0D0 .OR. THMAX.LT.0.0D0) THEN
         WRITE(0,*) ' DSETUP: THPH: ERROR  THETAS MUST BE POSITIVE'
         STOP
      ENDIF
C
C GET THE CORNERS OF THE DETECTOR.
      CALL UNIT(THMAX,PHMIN,CORNER(1,1))
      CALL UNIT(THMAX,PHMAX,CORNER(1,2))
      CALL UNIT(THMIN,PHMAX,CORNER(1,3))
      CALL UNIT(THMIN,PHMIN,CORNER(1,4))
C
C SIDES 1 AND 3 ARE LINES OF LATITUDE.
C THE SEGMENTS GO COUNTER-CLOCKWISE FROM PHMIN TO PHMAX.
      IF(PHMIN.LT.-180.0D0) PHMIN=PHMIN+360.0D0
      IF(PHMIN.GT.180.0D0) PHMIN=PHMIN-360.0D0
      IF(PHMAX.LT.-180.0D0) PHMAX=PHMAX+360.0D0
      IF(PHMAX.GT.180.0D0) PHMAX=PHMAX-360.0D0
      SHORT=(PHMIN.LT.PHMAX.AND.PHMAX-PHMIN.LE.180.0D0) .OR.
     1          (PHMIN.GT.PHMAX .AND. PHMIN-PHMAX.GT.180.0D0)
C
      CALL UNIT(0.0D0,0.0D0,DCIRC(1,1))
      DCIRC(4,1)=DCOS(THMAX*PI/180.0D0)
      CALL SEGMNT(DCIRC(1,1),CORNER(1,1),CORNER(1,2),SHORT,DSEG(1,1))
C
      CALL UNIT(0.0D0,0.0D0,DCIRC(1,3))
      DCIRC(4,3)=DCOS(THMIN*PI/180.0D0)
      CALL SEGMNT(DCIRC(1,3),CORNER(1,3),CORNER(1,4),SHORT,DSEG(1,3))
C
C SIDES 2 AND 4 ARE GEODESICS.
      CALL GSGMNT(CORNER(1,2),CORNER(1,3),.TRUE.,DCIRC(1,2),DSEG(1,2))
      CALL GSGMNT(CORNER(1,4),CORNER(1,1),.TRUE.,DCIRC(1,4),DSEG(1,4))
C
C FIND THE INSIDE POINT.
      IF(PHMIN.LE.PHMAX) THEN
         CALL UNIT(.5D0*(THMIN+THMAX),.5*(PHMIN+PHMAX),XDTECT)
      ELSE IF(PHMIN.GT.PHMAX) THEN
         PPHHII=PHMIN+.5D0*(360.0D0-(PHMIN-PHMAX))
         CALL UNIT(.5D0*(THMIN+THMAX),PPHHII,XDTECT)
      ENDIF
      RETURN
      END
